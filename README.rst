Di0Zone проект
==============

Проект предназначен для автоматизации рутинных повседневных задач. Основной из них является поддержание рабочего окружения в актуальном состоянии в условиях, когда приходится работать на нескольких рабочих местах, кочуя от одного к другому.

Установка производится в домашний каталог пользователя в следующие подкаталоги:

- `${HOME}/.local/share/Di0Zone/bin` - исполняемые скрипты;
- `${HOME}/.local/share/Di0Zone/lib` - файлы библиотек;
- `${HOME}/.config/Di0Zone` - файлы конфигурации;
- `${HOME}/.local/share/applications` - файлы Desktop Entry File;
- `${HOME}/.local/share/icons` - файлы пиктограмм для Desktop Entry File;
- `${HOME}/.local/share/systemd/user` - файлы Systemd;
- `${HOME}/.local/state/Di0Zone` - файлы, образующиеся в процессе работы скриптов (протоколы, резервные копии удалённых файлов).

Все файлы проекта (за исключением тех, которые идут на подмену файлов из других проектов) имеют приставку "dz\_", по которой их легко распознать и, при необходимости, вычистить из системы.

Для исполняемых файлов в каталоге ``${HOME}/.local/bin`` создаются символические ссылки, по которым их можно запускать на исполнение. Необходимо проследить, что бы данный каталог находился в переменной ``${PATH}`` окружения пользователя.

Проект работает в окружении пользователя. В проекте задействованы механизмы freedesktop.org и systemd. Необходимы терминал alacritty, Rsync, клиент SSH и сервер с доступом по SSH, Python3.

Проект состоит из нескольких компонентов, описанных ниже.

Компонент DZ_SYNC
-----------------

Данный компонент является надстройкой над хорошо известной в мире Linux утилитой копирования файлов Rsync.

Синтаксис:

.. code::

    dz_sync[_pull|_push].sh [<каталог1>[ <каталог2>]...]

Основная задача данного компонента - поддержание в актуальном состоянии своего рабочего окружения (по-умолчанию, внутри домашнего каталога) на нескольких компьютерах сразу. Так, например, мне приходится работать на 5-ти рабочих местах. И хотелось бы, что бы мои рабочие файлы, при переходе с места на место, приводились в идентичное состояние. Т.е., если я сделал какие-либо изменения на одном рабочем месте, то должен быть механизм, который эти изменения перенесёт на другое рабочее место, при переходе на него. Этим и занимается данный компонент проекта.

Синхронизация данных производится посредством сервера, который хранит текущее состояние рабочего окружения. Доступ к серверу осуществляется по протоколу SSH. На сервере для размещения синхронизируемых каталогов должен быть доступен для записи каталог ``/srv/rsync/dz_sync``.

Начало работы на каждом рабочем месте начинается с загрузки изменений в рабочем окружении с сервера, которые были сделаны перед уходом с другого рабочего места. По окончании работы, все сделанные изменения переносятся на сервер, и работа на другом месте начинается с их загрузки, приведя рабочее окружение в то состояние, в котором оно было оставлено на предыдущем рабочем месте.

Компонент состоит из скрипта ``dz_sync.sh`` и конфигурационного файла ``dz_sync.conf``. Будучи запущенным, скрипт самостоятельно определяет с какого компьютера были сделаны последние изменения на сервере, и, в зависимости от этого, выбирает, следует забрать их (PULL) или отправить (PUSH). Удобство использования утилиты Rsync в том, что она самостоятельно определяет изменения в файлах и осуществляет передачу только тех, которые претерпели изменения, что значительно снижает трафик и время, затрачиваемое на синхронизацию данных.

Список каталогов, подлежащих синхронизации, ``dz_sync.sh`` получает из конфигурационного файла (массив SYNC_LIST) или из командной строки. В каждом каталоге, отправленном на сервер, на стороне сервера создаётся файл ``.dz_sync``, в котором записана информация об имени узла, с которого производилась последняя синхронизация, время и направление синхронизации.

Для утилиты ``dz_sync.sh`` в каталоге ``${HOME}/.local/bin`` создаётся, помимо прямой ссылки, ещё две ссылки - ``dz_sync_pull.sh`` и ``dz_sync_push.sh``, которые задают конкретное направление синхронизации.

Работа компонента не ограничивается только синхронизацией каталогов внутри рабочего окружения. Можно сохранять каталоги и вне его, указав их в командной строке, например системные настройки из ``/etc``. Главное условие, у пользователя должны быть права на чтение сохраняемой информации. Необходимо иметь ввиду разное поведение компонента с каталогами, находящимися внутри рабочего окружения и вне его. Для первых выполняется весь комплекс синхронизации, как автоматическое определение направления, загрузка на сервер, получение с него. Каталоги же за пределами рабочего окружения могут быть только загружены на сервер. При этом на сервере они помещаются в отдельный каталог ``_ext/имя_компьютера``. Обратная загрузка с сервера запрещена. Это предохраняет файлы от изменения средствами данного компонента, что может быть опасно -- ну давайте попереназапиcываем файлы, например, в каталоге ``/etc`` :-E. Не думаю, что из этого получится что-то хорошее. В лучшем случае система разграничения доступа не позволит этого сделать, в худшем можно привести систему в нерабочее состояние.

При синхронизации не происходит безвозвратной потери стёртых в рабочем окружении файлов. Все стёртые файлы помещаются на стороне клиента в каталог ``${HOME}/.local/state/Di0Zone/dz_sync.trash``, на стороне сервера в каталог ``/srv/rsync/dz_sync/_trash``. Для исключения их переполнения, происходит удаление каталогов старше указанного в параметре ``TRASH_AGE`` количества дней.

.. note
    Адреса сервера хранятся в конфигурационном файле в переменной ``SERVER_ADDRESSES``.


Для интеграции в окружение рабочего стола, поставляются desktop-файлы ``dz_sync.desktop, dz_sync_pull.desktop, dz_sync_push.desktop`` благодаря которым скрипт можно вызывать из контекстного меню файлового менеджера щелчком на каталоге или из основного меню. Дополнительно, ссылка на ``dz_sync.sh`` устанавливается в каталог автозагрузки, что бы обеспечить запуск синхронизации при входе пользователя в систему.

Компонент DZ_ENCFS
------------------

В своей работе я использую Encfs для шифрования каталогов с чувствительной информацией. Данный компонент помогает управлять процессом их расшифровки и монтирования и является надстройкой над утилитой Encfs.

Синтаксис:

.. code::

    dz_encfs.sh <зашифрованный_каталог.enc>

Требования компонента:

- должна быть установлена утилита Encfs;
- зашифрованные каталоги должны быть созданы, и иметь расширение .enc;
- монтирование расшифрованного каталога производится в каталог с тем же именем, но без расширения;
- параметры шифрования должны быть настроены средствами самой EncFS;
- XML файл конфигурации зашифрованного каталога должен храниться отдельно от него, иметь такое же имя, как у каталога, без расширения. Местом хранения файла установлен каталог ``${HOME}/.ssh/encfs``.

При передаче скрипту, в качестве параметра, имени зашифрованного каталога, он его расшифрует и смонтирует в каталог (точку монтирования) с таким же именем, но без расширения. В случае же, если каталог уже смонтирован, произойдёт его размонтирование и удаление точки монтирования.

Так же этому скрипту соответствует desktop-файл ``dz_encfs.desktop``, благодаря которому скрипт интегрируется в окружение рабочего стола, в частности, его можно вызывать из контекстного меню файлового менеджера на зашифрованном каталоге.

Компонент DZ_SHUTDOWN
---------------------

Главная цель этого компонента вызвать DZ_SYNC для синхронизации рабочего окружения, DZ_ENCFS для размонтирования шифрованных каталогов и выключить компьютер.

Синтаксис:

.. code::

    dz_shutdown.sh

Необходимость компонента заключается в том, что, порой я, по забывчивости, уходил с рабочего места не сделав синхронизации, и, придя на другое, мог только развести руками. Вся сделанная работа оставалась на предыдущем месте и была не доступна на новом. Так что компонент можно рассматривать как эдакую "защиту от дурака". Вызов DZ_SHUTDOWN удобно закрепить за горячей клавишей (у меня CTRL-ALT-Backspace) и приучить себя завершать работу её нажатием.

Компонент TOOLS
---------------

Данный компонент предназначен для настройки рабочего окружения. Он не устанавливает своих файлов, однако вносит изменения в конфигурации существующего программного обеспечения, что бы привести его удобное для себя состояние. Очевидно, что настройка программ под себя является, иногда, трудоёмким и длительным процессом, удачная конфигурация подбирается, порой, годами с потом, кровью и слезами, а потом вырабатывается привычка работы с ней, и работа с программой, настроенной под кого-то другого или с настройками по умолчанию, вызовет существенный дискомфорт.

Данный компонент не ставит задачу сохранения конфигурации всего программного обеспечения на рабочем компьютере. Оно, обычно, настраивается один раз и работает долгие годы без изменений. Однако, возникают ситуации, когда это надо делать чаще. Например, я по своей работе, в рамках тестирования, часто вынужден переустанавливать операционные системы, заводить и удалять тестовых пользователей, чистить их домашние каталоги, кочевать с одного рабочего места на другое, смотреть "а что произойдёт если...<далее вырезано цензурой:-)>". При каждой такой манипуляции я получаю постоянно используемую мной программу Midnight Commander запущенную с чистого листа в конфигурации по умолчанию, которая мне не удобна. Время, затрачиваемое на перенастройку программы, которую приходится проводить по несколько, иногда десятков, раз в день становится существенным. Вот и возникла идея свести её к набору всего одной команды ``make config``.

Установка и удаление
--------------------

Установка производится командой:

.. code::

    make install

Для удаления используется команда:

.. code::

    make clean

При этом сохраняются файлы протоколов и конфигурационные файлы. Если нужно удалить и их, то используется команда:

.. code::

    make purge

Все команды выполняются из каталога проекта, там, где размещён Makefile.

Так же можно всё удалить вручную, удалив из домашнего каталога все файлы с приставкой "dz\_".

Bags and features
-----------------

1. Обнаружился интересный  эффект. Если какой-либо подкаталог или файл находится в списке игнорируемых (переменная ``SYNC_FILTER`` в файле конфигурации ``dz_sync.conf``), то он игнорируется не только при синхронизации, но при удалении тоже! Соответственно, в процессе синхронизации, ни он, ни содержащий этот подкаталог или файл и не будет удалены. Будет получена ошибка "cannot delete not-empty directory".

2. Следует отметить, что с точки зрения Rsync, синхронизация переименованного каталога или файла равносильна загрузке его на приёмную сторону вновь под новым именем и удалению того, что хранилось там под старым именем. Так что осторожнее с переименованием каталогов, содержащих большое количество файлов или больших по размеру файлов. Они будут загружаться вновь, что потребует времени.
